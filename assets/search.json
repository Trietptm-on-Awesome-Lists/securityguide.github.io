[{
  "title": "Abusing Cookies",
  "url": "/webappsec/fundamentals/abusing-cookies.html",
  "tags": "",
  "content": "How cookies work  If you have ever done any web programming, you are familiar with cookies. However, you might not be familiar with some of the unexpected ways in which cookies can create security vulnerabilities.  A look at cookies  Let us start at the beginning: what is a cookie? The HTTP cookie allows a server to store a bit of arbitrary data on the client’s device. A cookie is just a KEY=VALUE pair, with some associated attributes the direct the browser when the cookie should be used.  Cookies are just headers set by the server in the HTTP response or by the client in the HTTP request. For example:  1. client -&gt; server request  curl --head -v https://en.wikipedia.org/wiki/Main_Page 2&gt;&amp;1 | grep '^&gt;'    SIDE NOTE: the `grep '^&gt;'` command will show us just the client's request headers  &gt; HEAD /wiki/Main_Page HTTP/1.1 &gt; Host: en.wikipedia.org &gt; User-Agent: curl/7.47.0 &gt; Accept: */*   2. client &lt;- server response  curl --head -v --cookie-jar /tmp/cookie https://en.wikipedia.org/wiki/Main_Page 2&gt;&amp;1 | grep '^&lt;'    SIDE NOTE:     * the `--cookie-jar` argument will save the cookies to the file specified     * the `grep '^&lt;'` command will show us just the server's response headers  Server responds with two Set-Cookie headers:  &lt; Set-Cookie: WMF-Last-Access=04-Nov-2016;Path=/;HttpOnly;secure;Expires=Tue, 06 Dec 2016 12:00:00 GMT &lt; Set-Cookie: GeoIP=US:::37.75:-97.82:v4; Path=/; secure; Domain=.wikipedia.org   3. client -&gt; server request  curl --head -v --cookie /tmp/cookie https://en.wikipedia.org/wiki/Main_Page 2&gt;&amp;1 | grep '^&gt;'  When the client next mades a request, it will send these cookies in the request header:  &gt; HEAD /wiki/Main_Page HTTP/1.1 &gt; Host: en.wikipedia.org &gt; User-Agent: curl/7.47.0 &gt; Accept: */* &gt; Cookie: WMF-Last-Access=31-Oct-2016; GeoIP=US:::37.75:-97.82:v4   Domains and Paths          If the domain is not explicitly set by the server, the browser will assign the domain based on the origin of the cookie.           Sub-domains can set cookies for the parent domain: A page can set a cookie for its own domain or any parent domain, as long as the parent domain is not a public suffix. In other words, sub.domain.org can set a cookie for domain.org, which will also be used for sub2.domain.org. Firefox and Chrome use the Public Suffix List to determine if a domain is a public suffix.           A cookie for a parent domain is always sent to the sub-domain: a cookie with domain=domain.org or domain=.domain.org will be sent to sub.domain.org. Because of this, a compromise on domain.org can result in session fixation vulnerability for all the subdomains.           Cookie scheme for determining origin is very different than the same-origin policy. The short hand version: cookie domain is a loose match, same-origin is a very strict match, including protocol and port.      Cookie Flags  A cookie flag is a suggestion to the client regarding when a cookie should be used.  Example:  Set-Cookie: KEY=VALUE; Secure; HttpOnly; SameSite=Strict   Secure  The secure flag suggests to the client that they cookie should only be used for requests over https.  Why this is highly recommended:     Suppose your browser has an active session to https://securebank.int, then you type in ‘securebank.int’ in another tab. Without the Secure flag, your browser has just leaked your session id in the clear over the network! This is true even if you don’t serve any content on plaintext http and always redirect to https.   HttpOnly  This flags prevents javascript from reading the value of the cookie.  Why this is highly recommended:     This flag makes it harder for XSS attacks to hijack your session by reading the cookie and exfiltrating the session id to the attacker’s domain.   SameSite=Strict  This flag prevents the cookie from being used by other web pages when they submit forms or get resources from the cookie’s domain.  Why this is highly recommended:     SameSite restrictions are a good way to mitigate CSRF attacks.   Cookie facts     Cookie size: Cookies can hold no more than 4096 bytes.   Duplicate Cookies: It is possible to have multiple cookies with the same name for the same domain. The server must not rely on any particular order of the cookies.   Abusing Cookies  Session fixation  By resetting the session before setting critical information in the session, you protect against session fixation attacks.  Why this is important: There are many ways that an attacker can “pre-seed” a session cookie in the target’s browser. Once this is done, browsers follow a simple rule with cookies: if they have a cookie that matches the site, they send the cookie. Because of this, the website has no way to distinguish between legitimate session cookies that are created by the target and nefarious session cookies created by the attacker (and injected into the target’s browser).  Remember:     Encrypted and signed session cookies offer no defense against session fixation.   If you are using a third party authentication framework, you most likely still need to worry about resetting the session yourself. This includes SAML authentication libraries.   Session hijacking  To be written.  There are various ways that a session ID can leak. Then an attacker can assume your session.  Cross site request forgery  When a web browser submits a HTTP request, it dutifully includes all matching cookies, regardless of what web page the request came from. Without protection from Cross Site Request Forgery (CSRF), a web page on a completely different site can get your browser to make requests to a protected site while authenticated as you.  Remember:     Idempotent HTTP GET: You must remember to make all GET actions idempotent (does not change the data). This is because most schemes for anti-CSRF only applies to HTTP POST.   Images are not protected: Images and other assets are not protected by most anti-CSRF or the same-origin policy. If you have images with sensitive information, then you need an additional system to prevent a third party site from stealing these images.   If the application has a XSS vulnerability, then CSRF is also defeated.   Parsing cookies  To be written.  Cookies are untrusted input. If there is a bug in the parsing code, such as a JSON or XML library, then an attacker can exploit it via cookies"
},{
  "title": "Abusing Filesystems",
  "url": "/webappsec/fundamentals/abusing-filesystems.html",
  "tags": "",
  "content": "temp files   relative paths   path injection   predictable paths   file uploads"
},{
  "title": "Abusing Input",
  "url": "/webappsec/fundamentals/abusing-input.html",
  "tags": "",
  "content": "SQL Injection  “SQL Injection” is a security vulnerability with a very simple cause: it occurs whenever user input is not properly filtered when SQL queries are built.  It is one of the most common vulnerabilities, can lead to total compromise of the database, and is also easy to prevent.  To prevent SQL Injection:     Always use parameter binding. Almost all libraries for accessing a database include some API for “parameter binding”. You should always use these built-in methods.   Avoid every trying to filter input yourself. Use the parameter binding feature that is already built into the database library you are using.   If you are creating a custom query that must bypass parameter binding, try to exercise extreme caution. For example, only allow a very limited set of characters in the user input.   Examples  A vulnerable query (java):  String query = \"SELECT account_balance FROM user_data WHERE user_name = \" + request.getParameter(\"customerName\"); Statement statement = connection.createStatement(...); ResultSet results = statement.executeQuery(query);   In this vulnerable query, if the parameter customerName contained ''; DROP TABLE user_data; then an attacker could destroy the database (there are other techniques that can be used to exfiltrate data as well).  A safe query using parameter binding (java):  String custname = request.getParameter(\"customerName\"); String query = \"SELECT account_balance FROM user_data WHERE user_name = ? \"; PreparedStatement pstmt = connection.prepareStatement(query); pstmt.setString(1, custname); ResultSet results = pstmt.executeQuery();   Where it gets tricky  Many database APIs will not use parameter binding for all calls, even when it looks like they do. For example, in Ruby using ActiveRecord, this call is unsafe:  User.exist?(params[:id])   If params[:id] is encoded as an array by the attacker, then it will allow an attacker to bypass any input filtering.  A static analysis tool in your test pipeline should help detect these sort of non-obvious errors for you.  Further reading     netspi SQL wiki, An excellent in-depth look at SQL injection.   OWASP page on SQL injection   OWASP SQL Injection Prevention Cheat Sheet"
},{
  "title": "Access Controls",
  "url": "/webappsec/best-practices/access-controls.html",
  "tags": "",
  "content": "Are there tests for failed authentication states?  https://martinfowler.com/articles/web-security-basics.html     Use existing authentication frameworks whenever possible instead of creating one yourself   Support authentication methods that make sense for your needs   Limit the ability of an attacker to take control of an account   You can take steps to prevent attacks to identify or compromise accounts   Never use default or hard-coded credentials   Proper Access Controls  This one is tricky as it is very dependent on the context of your application. Here are some things to consider:     How do users authenticate? Are you using a secure library?   Should only privileged users have access to certain resources? Where are these roles stored? Could they be manipulated by user input?   What systems/services can access your database?   This last point is absolutely critical. App context varies, but an anonymous user/system/service should never be able to access your database. Make sure there is a strong authentication model for your database.  More Resources:     OWASP Authentication Cheat Sheet   MongoDB   AWS Elastic Search   MySQL   PostgreSQL   Microsoft SQL Server"
},{
  "title": "Agnostic dependency check",
  "url": "/webappsec/tools/agnostic-tools/agnostic-dependency-checker.html",
  "tags": "",
  "content": "Hawkeye  Hawkeye (free, cli and SaaS) https://github.com/Stono/hawkeye and https://hawkeye.website"
},{
  "title": "Agnostic dynamic analysis",
  "url": "/webappsec/tools/agnostic-tools/agnostic-dynamic-analysis.html",
  "tags": "",
  "content": "Arachni  Arachni is a web application security scanner framework that works well with Rails, but can also be used with many frameworks."
},{
  "title": "Agnostic secrets management",
  "url": "/webappsec/tools/agnostic-tools/agnostic-secrets-management.html",
  "tags": "",
  "content": "I don’t think you need to be scared into not checking secrets in – you probably already understand that this is bad (maybe). Just in case, here is a handy rule: never commit cleartext secrets of any kind to git, no matter what.  Environment variables  AWS Parameter Store  https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html  GoCD  go-env https://docs.gocd.org/15.3.0/faq/dev_use_current_revision_in_build.html  Heroku  https://devcenter.heroku.com/articles/config-vars  Encrypted in cloud storage  cred-stash  Store secrets in AWS using encrypted S3 buckets  https://github.com/fugue/credstash  Vault  https://www.vaultproject.io/  Encrypted in source code  git-crypt  With git-crypt, you can store files in git that are automatically encrypted using GnuPG.  Install  $ brew install gnupg git-crypt   Initialize in your repo  $ cd my_project $ git crypt init   Add public keys that can decrypt the files:  $ git-crypt add-gpg-user USER_ID   Specify which files should be encrypted in the .gitattributes file:  *.key filter=git-crypt diff=git-crypt   After cloning a repository with encrypted files, unlock with:  $ git-crypt unlock   Check which files are encrypted:  $ git crypt status   BlackBox  https://github.com/StackExchange/blackbox  Like git-crypt, blackbox helps you store secrets in git using GnuPG. Blackbox will also with any source control, not just git.  With BlackBox, however, nothing is automatic. If you want to edit a file, you must decrypt it first. In contrast, git-crypt is automatic, which can be weird and confusing. The BlackBox approach can be more comforting and safe, because you never commit what appears to be a cleartext file. But the manual approach can also be painfully laborious.  Install  $ brew install blackbox   Initialize in your repo:  $ cd my_project $ blackbox_initialize   Add public keys that can decrypt the files:  $ blackbox_addadmin coworker@thoughtworks.com   Specify what files should be encrypted:  $ blackbox_register_new_file path/to/file.name.key   Unlock, edit, lock, commit:  $ blackbox_edit_start FILENAME ... edit file ... $ blackbox_edit_end FILENAME $ git commit ...   Further reading  https://12factor.net/config"
},{
  "title": "Agnostic static analysis",
  "url": "/webappsec/tools/agnostic-tools/agnostic-static-analysis.html",
  "tags": "",
  "content": "GrepBugs  GrepBugs is a regex-based static analysis tool that looks for potentially dangerous methods and patterns in your code. Given that this is regex, it can be noisy, but the reports provide enough context to quickly weed out false positives.  Another helpufl aspect of GrepBugs is that it gives you quick feedback about the numbers of file types, and even lines of code present.  Installation &amp; Usage  To install GrepBugs, you simply clone the GitHub repository:  $ git clone https://github.com/foospidy/GrepBugs.git   I’d recommend either:     cloning it into your project folder        placing it in your home directory and adding the following line to your .bash_profile:      $ alias grepbugs =’python2 ~/Grepbugs/grepbugs.py’      This will allow you to run a scan anywhere, all you have to do is set the target path:  $ grepbugs -d my/project   Other Notes  When you run a scan, the output will be created in the ‘out/’ folder. By default, two files will be created for every scan: .html and .txt  The default name for the scan will be the path you provided."
},{
  "title": "Contributing",
  "url": "/contributing.html",
  "tags": "",
  "content": "Simple method: editing on Github  Learning to use git can be very difficult. As an alternative, it is possible to contribute to security.git by directly editing pages through the Github website. This method does not let you preview how the page will render, but it does allow you to contribute edits without needing to install any software.  First, you need to register a github.com account. Then visit github.com/thoughtworks/security.  To edit files:     Existing Files: You can edit an existing file by clicking on the file name and then clicking the “Edit” button in the file’s toolbar (it looks like pencil). To save, type a commit message and hit the “Propose file change” button.   New Files: You can add a new page by clicking the “+” button at the end of the path breadcrumbs (e.g. “security / pages / netsec / [+]” near the top of the page). When you are done editing the content, hit the “Propose new file” button.   Boom, you are done. Someone will review the change request and either merge it right away or add comments.  Advanced method: using git and Jekyll  Clone the repository          Fork the project repository by clicking on the ‘Fork’ button near the top right of the page. This creates a copy of the code under your GitHub user account. For more details on how to fork a repository see this guide.           Clone your fork of the security repo from your GitHub account to your local disk:      $ git clone git@github.com:YOUR_GITHUB_LOGIN/security.git $ cd security                Create a feature branch to hold your development changes:      $ git checkout -b my-feature                Modify the pages in your feature branch. Add changed files using git add and then git commit files:      $ git add modified_files $ git commit           Then push the changes to your GitHub account with:      $ git push -u origin my-feature                Issue a pull request      Go to https://github.com/YOUR_GITHUB_LOGIN/security and push the button to issue a pull request. Someone will review your changes and merge them or comment on them.  Installing Jekyll  In order to preview your edits before you commit them, you will need a program called jekyll.  Install bundler for Mac:  $ brew install ruby $ gem install bundler   Install bundler on Debian/Ubuntu:  # apt install ruby ruby-dev build-essential # gem install bundler   Install jekyll:  $ cd security $ bundle   Previewing pages  When you are making changes, you can prevew the changes by running the jekyll server:  $ cd security $ make serve   Then browse to http://localhost:4000. Any page you view this way gets re-rendered when it is loaded.  After you have made changes, run this command to completely render the static HTML for the entire site:  $ cd security $ make build   Putting it all together     Go to https://github.com/securityguide/securityguide and click the fork button.   Clone your fork locally: git clone ssh://git@github.com/YOUR_GITHUB_LOGIN/security   Start the amber server: cd security; make serve   Edit files in security/pages   Preview changes in your browser using http://localhost:4000   When satisfied, git commit, git push   Go to https://github.com/YOUR_GITHUB_LOGIN/security and push the button to issue a pull request.   Keeping up to date  After a while, your fork of the repo will become out of date. In order to refresh it with the lastest upstream content:  $ git remote add upstream https://github.com/securityguide/securityguide $ git checkout master $ git fetch upstream $ git rebase upstream/master   Editing tips  Syntax  These pages use Markdown syntax (Kramdown flavored).  Wiki links  In addition to traditional Markdown syntax for links, you can use wiki-style links, like so:  \\[[page_name]] \\[[page_name|Title]] \\[[Title =&gt; page_name]]   Using wiki-style links is highly preferred, because these links will not break when a page moves and missing links will produce an error notice.  Includes  You can mix in Liquid tags in your Markdown pages. For example, this text:     {% include blah.md %}   Will insert the contents of pages/_includes/blah.md into the current page.  To include a formatted code block:     ```bash  {% include script.sh %}  ```   Additionally, you can include any page in another page via the include_page plug in:     {% include_page secret_management %}   This will insert the contents of secret_management.md into the current page, regardless of where the file secret_management.md lives in the directory structure.  Navigation menu  To update the left side navigation menu, edit the file pages/_data/menu.yml."
},{
  "title": "Content Security Policy",
  "url": "/webappsec/best-practices/csp.html",
  "tags": "",
  "content": "Description  Content Security Policy limits the resources that a web browser will load, making it more difficult for attackers to carry out a Cross Site Scripting attack.  When enabling CSP, we can define a whitelist of resources that the browser will load. Any resources (even including inline scripts) that are not explicitly enabled in the whitelist will be blocked by the browser.  As an exploit mitigation, it’s important to remember that while CSP makes exploitation more difficult, it does not prevent the bugs that make an exploit possible in the first place (lack of appropriate encoding/sanitization). Therefore, its protection will never be complete, and people will continue to find bypasses for even the most rigerous policies. That said, it’s an important part of a Defense in Depth strategy for any web application.  Acceptance Criteria     A policy is created that blocks any resources not required by the application   The policy is enabled via the Content-Security-Policy header   An api or service is created to parse CSP reports   Reporting is enabled via the report-uri directive   The team understands what limitations CSP adds, and how to check for violations   The team has a process for updating the policy as requirements change   Resources     https://scotthelme.co.uk/content-security-policy-an-introduction/   https://developers.google.com/web/fundamentals/security/csp/"
},{
  "title": "Dependency Checker",
  "url": "/webappsec/best-practices/dependency-check.html",
  "tags": "",
  "content": "What is it?  A dependency checker is a tool that attempts to detect when updates are available for third party dependencies (libraries, frameworks, etc) used in your application due to publicly disclosed security vulnerabilities.  Why is it needed?     Up to 90% of many applications are comprised of third party components.   Applications often inadvertently introduce vulnerabilities by failing to update components in a timely manner or by pulling in outdated components with vulnerabilities.   When should I use this?  All the time.  Using components with known vulnerabilities is a widespread and serious problem in application development. It can lead to easy, scannable vulnerabilities in your app. Recommended tools for a variety of languages are provided elsewhere in this project:  Tools     [[agnostic-dependency-checker]]   [[java-dependency-checker]]   [[javascript-dependency-checker]]   [[python-dependency-checker]]   [[ruby-dependency-checker]]   Further reading     https://www.owasp.org/index.php/OWASP_Dependency_Check"
},{
  "title": "Environment Isolation",
  "url": "/webappsec/best-practices/environment-isolation.html",
  "tags": "",
  "content": "No Production Data in Non-production Environments Dev, QA, and staging environments (and their equivalents) often do not have the same care and security measures that are applied to a production environment. Additionally, this is where we do our testing – where we break things and elicit unexpected behavior.  Real Data in App Testing Poses Real Risks The Security Threat From Within"
},{
  "title": "ExpressJS Pre-flight Checklist",
  "url": "/webappsec/checklists/javascript-checklists/expressjs.html",
  "tags": "",
  "content": "tools  https://www.npmjs.com/package/helmet help secure Express/Connect apps with various HTTP headers  Commercial Tools https://geekflare.com/nodejs-security-scanner/  OWASP Dependency Check  https://jeremylong.github.io/DependencyCheck/dependency-check-cli/index.html  For javascript, you need --enableExperimental  dependency-check.sh --enableExperimental --project 'xxxx' --scan /path/to/project   http://expressjs.com/en/advanced/best-practice-security.html  secure cookie options  const express = require('express') const session = require('express-session')  const app = express() const hour = 3600000 app.use(session({   cookie: { secure: true, sameSite: true, maxAge: hour } }))   secure header options  const express = require('express') const helmet = require('helmet')  const app = express() app.use(helmet())   https://github.com/helmetjs/helmet  csrf  https://www.npmjs.com/package/csurf"
},{
  "title": "Generic Pre-flight Checklist",
  "url": "/webappsec/checklists/generic-checklist.html",
  "tags": "",
  "content": "Configuration  Secrets are stored securely  A “secret” includes passwords, API keys, and private keys.     No cleartext secrets in git   Secrets may be:            Encrypted, (e.g. git-crypt)       Stored in the environment       Stored in secure storage (e.g. credstash)           Anti-CSRF is enabled  When a web browser submits a HTTP request, it dutifully includes all matching cookies, regardless of what web page the request came from. Without CSRF protection, a nefarious page can get your browser to make requests to a protected site while authenticated as you.  Remember:     Idempotent HTTP GET: You must remember to make all GET actions idempotent (does not change the data). This is because the Rails anti-CSRF only applies to HTTP POST.   Images are not protected: Images and other assets are not protected by the Rails anti-CSRF or the same-origin policy. If you have images with sensitive information, then you need an additional system to prevent a third party site from stealing these images.   If the application has a XSS vulnerability, then CSRF is also defeated.   Cookies and sessions     Authentication always triggers a session reset   data in cookies is untrusted, unless signed   sessions have a max lifetime   sessions expire after inactivity   HTTP Headers     Enable secure headers   Sensitive content is not cached   Cache-Control: max-age=0, private, no-store   Secure connections     TLS is required in production   Database connections are secure   Other inputs and outputs   APIs?   Input Validation     Input has restrictive validation   All queries use parameter binding   No mass assignment   Output Filtering     User input is not used to build file paths   All output is filtered, even if the data has been previously validated.   Authorization     Reasonable authentication system   The default is to require authorization   follows principles of least privilege   Pipeline     Dependency checks are run in pipeline   Static analysis is run in pipeline   Routing and URLs     There is no sensitive information in any application URLs   All stylesheets have absolute paths   Documentation     Purpose of application   Security considerations   How application is installed, configured, and run   Logging     Logging is centralized"
},{
  "title": "Enforce HTTPS",
  "url": "/webappsec/best-practices/https.html",
  "tags": "",
  "content": "Protect Data in Transit     Use HTTPS for everything!   Use HSTS to enforce it   You will need a certificate from a trusted certificate authority if you plan to trust normal web browsers   Protect your private key   Use a configuration tool to help adopt a secure HTTPS configuration   Set the “secure” flag in cookies   Be mindful not to leak sensitive data in URLs   Verify your server configuration after enabling HTTPS and every few months thereafter   Enforce HTTPS  Please just do it. Enforcing HTTPS is the best policy, for many many reasons.  Unfortunately, enforcing HTTPS on the server does not not necessarily mean that the browser will not attempt plaintext HTTP connections. If the browser has a session cookie, then these plaintext connection attempts will leak the session to any network observer.  To prevent session hijacking and SSL striping attacks, you need to additional enable the following:     Ensure that the [[Secure cookie flag is set =&gt; abusing-cookies]].   Ensure that HTTP Strict Transport Security (HSTS) is set.   Understanding X.509  To be written  Recommended configuration  Web server configurations that enforce HTTPS and also use a good cipher list.  Apache  &lt;VirtualHost *:80&gt;   ServerName DOMAIN   ServerAlias WWW_DOMAIN   RewriteEngine On   RewriteRule ^.*$ https://DOMAIN%{REQUEST_URI} [R=permanent,L] &lt;/VirtualHost&gt;  &lt;VirtualHost *:443&gt;   ServerName DOMAIN   ServerAlias WWW_DOMAIN    SSLEngine on   SSLProtocol all -SSLv2 -SSLv3   SSLHonorCipherOrder on   SSLCompression off   SSLCipherSuite \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!RC4:!MD5:!PSK!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\"    RequestHeader set X_FORWARDED_PROTO 'https'    SSLCACertificatePath /etc/ssl/certs   SSLCertificateKeyFile /path/to/private.key   SSLCertificateFile /path/to/cert.crt    &lt;IfModule mod_headers.c&gt;     Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"     Header always unset X-Powered-By     Header always unset X-Runtime   &lt;/IfModule&gt; &lt;/VirtualHost&gt;   Nginx  To be written  Client certification authentication  To be written"
},{
  "title": "Ruby Checklists",
  "url": "/webappsec/checklists/ruby-checklists/",
  "tags": "",
  "content": "[[rails-4]]   [[rails-5]]"
},{
  "title": "Sysadmin Best Practices",
  "url": "/netsec/best-practices/",
  "tags": "",
  "content": ""
},{
  "title": "Network Security",
  "url": "/netsec/",
  "tags": "",
  "content": ""
},{
  "title": "Web application security fundamentals",
  "url": "/webappsec/fundamentals/",
  "tags": "",
  "content": "These pages cover the core concepts behind the gritty details of how web applications work and common ways that web applications are compromised. For information on how to actually protect against attacks, see Web Application Checklists and Web Application Best Practices.  Security for web applications can feel like an endless pit of distraction: you can always learn more and there are always new attacks. However, learning the core basics of how cookies and javascript work will help you naturally write more secure code and also make you a better web developer.     Abusing Cookies: The surprisingly true tale of how cookies really work and all the ways in which they can be abused by attackers.     Abusing Filesystems     Abusing Input: Don't. Trust. The. User. Ever. That is pretty much it.     Other Tricks"
},{
  "title": "Python Tools",
  "url": "/webappsec/tools/python-tools/",
  "tags": "",
  "content": "Dependency check for Python     Static analysis for Python     Secrets management for Python"
},{
  "title": "Java Tools",
  "url": "/webappsec/tools/java-tools/",
  "tags": "",
  "content": "Dependency check for Java     Static analysis for Java     Secrets management for Java"
},{
  "title": "Javascript Tools",
  "url": "/webappsec/tools/javascript-tools/",
  "tags": "",
  "content": "Dependency check for Javascript     Static analysis for Javascript     Secrets management for Javascript"
},{
  "title": "Ruby Tools",
  "url": "/webappsec/tools/ruby-tools/",
  "tags": "",
  "content": "Dependency check for Ruby     Static analysis for Ruby     Secrets management for Ruby"
},{
  "title": "Agnostic Tools",
  "url": "/webappsec/tools/agnostic-tools/",
  "tags": "",
  "content": "Agnostic dependency check     Agnostic static analysis     Agnostic dynamic analysis     Agnostic secrets management"
},{
  "title": "Web Application Tools",
  "url": "/webappsec/tools/",
  "tags": "",
  "content": "Tools by languages     Agnostic: Web application security tools that work with all languages    Agnostic dependency check     Agnostic static analysis     Agnostic dynamic analysis     Agnostic secrets management     Java: Web application security tools for Java    Dependency check for Java     Static analysis for Java     Secrets management for Java     Javascript: Web application security tools for Javascript    Dependency check for Javascript     Static analysis for Javascript     Secrets management for Javascript     Python: Web application security tools for Python    Dependency check for Python     Static analysis for Python     Secrets management for Python     Ruby: Web application security tools for Ruby    Dependency check for Ruby     Static analysis for Ruby     Secrets management for Ruby   Dependency check  What is it?  A dependency checker is a tool that attempts to detect when updates are available for third party dependencies (libraries, frameworks, etc) used in your application due to publicly disclosed security vulnerabilities.  Why is it needed?     Up to 90% of many applications are comprised of third party components.   Applications often inadvertently introduce vulnerabilities by failing to update components in a timely manner or by pulling in outdated components with vulnerabilities.   When should I use this?  All the time.  Using components with known vulnerabilities is a widespread and serious problem in application development. It can lead to easy, scannable vulnerabilities in your app. Recommended tools for a variety of languages are provided elsewhere in this project:  Tools     [[agnostic-dependency-checker]]   [[java-dependency-checker]]   [[javascript-dependency-checker]]   [[python-dependency-checker]]   [[ruby-dependency-checker]]   Further reading     https://www.owasp.org/index.php/OWASP_Dependency_Check   Static analysis  What is it?  A static analysis tool, referred to as a Static Application Security Tool (SAST) in the context of security, identifies potential security flaws in source code, byte code, and binaries. SAST tools provide a powerful way to identify potential defects by analyzing applications from the “inside out”. This provides much greater sight into possible flaws than a scanner that only interacts with a application as a user would.  Why is it needed?     Sometimes the easiest or most obvious way to do something is also not secure. These tools provide fast feedback if a mistake is made.   Continuous, fast feedback about potential vulnerabilities saves teams time and stress.   When should I use this?     In your CI pipeline. Automatically run the scanner periodically, possibly alongside other automated tests following a checkin if it can complete quickly enough.   During manual testing. More in-depth scans can be run and verified along with the other necessary manual tests. Testers can also start to do some exploratory security testing after familiarizing themselves with typical weaknesses.   Tools     [[agnostic-static-analysis]]   [[java-static-analysis]]   [[javascript-static-analysis]]   [[python-static-analysis]]   [[ruby-static-analysis]]   Further reading     Wikipedia page on static program analysis   Wikipedia list of static program analyzers   OWASP wiki page on static program analysis   NIST list of security-focused static program analyzers   Dynamic analysis  To be written  Secret management  What is it?  Secrets such as passwords, credentials, access tokens, certificates, and other confidential information are something we can’t allow to fall into the wrong hands. A secret management tool makes it possible to manage these kinds of secrets safely.  Why is it needed?  We see this more than you’d think. The dangers of leaving secrets into your code are wide ranging and severe. It could lead to everything from an attacker compromising a user’s session to full owning your application, and even the application server, gaining access to your database, and impersonating you to uncover more valuable data (and this is not an exhaustive list).     Applications rely on secrets to access services such as databases, encrypted files, and to securely communicate with other applications and systems.   Team members may also need a way to manage and share similar confidential information.   Writing secrets in a place they can be easily retrieved exposes projects to unnecessary risks. This includes doing things like writing them on sticky notes or in source code or configuration files.   Tools     [[agnostic-secrets-management]]"
},{
  "title": "Javascript Checklists",
  "url": "/webappsec/checklists/javascript-checklists/",
  "tags": "",
  "content": "Platforms     [[expressjs]]   [[nodejs]]   Secure Coding Practices  Avoid stringify()  The command JSON.stringify() is not safe and can lead to XSS attacks.  Instead, use serialize-javascript:  $npm install --save-dev serialize-javascript      View on GitHub   Security risk details   Resources &amp; Advisories  https://medium.com/node-security"
},{
  "title": "Web Application Checklists",
  "url": "/webappsec/checklists/",
  "tags": "",
  "content": "Generic     Ruby    Rails 4     Rails 5     Javascript    NodeJS     ExpressJS   TODO: add acceptance criteria for major items, such as dependency check, static analysis, and secrets storage."
},{
  "title": "Tutorials",
  "url": "/webappsec/tutorials/",
  "tags": "",
  "content": "SAML with Ruby: How to add Okta SAML authentication to Ruby applications"
},{
  "title": "Web Application Best Practices",
  "url": "/webappsec/best-practices/",
  "tags": "",
  "content": "Validate User Input     Dependency Checker     Static analysis     Secrets Management     Access Controls     Content Security Policy     Environment Isolation     Enforce HTTPS     Logging"
},{
  "title": "Web Application Security",
  "url": "/webappsec/",
  "tags": "",
  "content": "Contents     Fundamentals: The core concepts behind the gritty details of how web applications work and common ways that web applications are compromised.    Abusing Cookies     Abusing Filesystems     Abusing Input     Other Tricks     Checklists: Essential things to check before deploying your web application into production.    Generic     Ruby     Javascript     Best Practices: A guide to the best practices when writing web applications.    Validate User Input     Dependency Checker     Static analysis     Secrets Management     Access Controls     Content Security Policy     Environment Isolation     Enforce HTTPS     Logging     Tools: Tools to help you write more secure web applications.    Agnostic     Java     Javascript     Python     Ruby     Tutorials    SAML with Ruby   Tasks     Read the fundamentals   Work through the checklist for your platform   Read the best practices   Use the tool section as a resource"
},{
  "title": "Operations Security",
  "url": "/opsec/",
  "tags": "",
  "content": "Level One     Password Manager            why unique and strong passwords matter: a reused password will get leaked, humans can’t compete with computers when it comes to thinking of random passwords.       has everyone on the team adopted a password manager?       unique passwords       strong passwords           Updates            why software updates matter       is everyone on the team applying updates regularly?       system updates       app updates           Secure browsing            keep browser up to date       https everywhere       ublock       disable flash and java           Email Caution            why everyone gets in trouble with email       what better email practice is vitally important to the organization       a few simple rules to always follow                    from can always be fake           attachments           links and url                           Disk Encryption            why it matters       does everyone on the team encrypt their laptop and phone?           Level Two     Cloud hygiene            why it matters, examples of sketchy apps       what cloudlock, etc can do for you           Backups   End-to-end encryption            Signal           Mindfulness            be suspicious                    phishing           links           asks for information                       limit personal information sharing           Software            do not side load software       no pirated software       Free software alternatives: gimp, libreoffice, inkscape, scribus, vlc.           Use a VPN   Device PIN   Level Three     U2F   Smart Cards   OpenPGP   Tor   Tails   Disk Wiping   Borders"
},{
  "title": "Validate User Input",
  "url": "/webappsec/best-practices/input.html",
  "tags": "",
  "content": "https://martinfowler.com/articles/web-security-basics.html  Reject Unexpected Form Input     White list when you can   Black list when you can’t whitelist   Keep your contract as restrictive as possible   Make sure you alert about the possible attack   Avoid reflecting input back to a user   Reject the web content before it gets deeper into application logic to minimize ways to mishandle untrusted data or, even better, use your web framework to whitelist input   Encode HTML Output     Output encode all application data on output with an appropriate codec   Use your framework’s output encoding capability, if available   Avoid nested rendering contexts as much as possible   Store your data in raw form and encode at rendering time   Avoid unsafe framework and JavaScript calls that avoid encoding   Bind Parameters for Database Queries     Avoid building SQL (or NoSQL equivalent) from user input   Bind all parameterized data, both queries and stored procedures   Use the native driver binding function rather than trying to handle the encoding yourself   Don’t think stored procedures or ORM tools will save you. You need to use binding functions for those, too   NoSQL doesn’t make you injection-proof   Validate User Inputs  If you have fields that accept user input in your application, making it a priority have some validations on this input is imperative to a basic level of security on your application.  An excellent blog post by Cade Cairns and Daniel Somerfield outlines some of the dangers of accepting as-is user input, along with some mitigation strategies.  Here are some of the main takeaways:     Accepting unvalidated input can lead to an attacker taking control of the app itself.   Setup alerts for potential attacks.   Whitelist (positive validation) expected inputs over blacklisting a set of known unwanted inputs (negative validation). Make your whitelist strict.   “Resist the temptation to filter out invalid input” aka “sanitization”. Reject invalid input altogether.   In a similar vein (and in the same blog post), take care to encode HTML output as well."
},{
  "title": "Dependency check for Java",
  "url": "/webappsec/tools/java-tools/java-dependency-checker.html",
  "tags": "",
  "content": "dependency-check  This dependency checker from OWASP is widely used and actively developed. It is compatible with Java/.NET, and there is currently experimental support other languages including Python.  Installation  There are a few ways to install dependency-check, but our best experience has been installing with Homebrew:  $ brew update &amp;&amp; brew install dependency-check   You can also download the dependency-check-cli zip file.  Usage  Dependency-check requires two arguments:     --scan (path to project you would like to scan)   --project (choose the name you would like for your project)   Check out the --advancedHelp option for some very specific options that could be well-suited to your project.  With Python projects, it is advisable to use the --enableExperimental flag since the features that scan Python files are still considered experimental by the Dependency Check project (don’t worry, we’re pretty confident in it regardless).  By default, the HTML report will be saved to whatever directory you are in when you run the scan. This file will be overwritten if no -o/--output or -f/--format are specified. Keep this in mind if you integrate this into your pipeline (as we hope you do!).  Documentation  The full documentation and the latest downloads can be found at: https://jeremylong.github.io/DependencyCheck/index.html  CI Integration  Some basic best practices/guidelines for adding OWASP Dependency Check to your CI pipeline can be found here: https://github.com/cairnsc/security-playbook/blob/master/tooling/dependency-checker/owasp-dependency-check.md"
},{
  "title": "Secrets management for Java",
  "url": "/webappsec/tools/java-tools/java-secrets-management.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Static analysis for Java",
  "url": "/webappsec/tools/java-tools/java-static-analysis.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Dependency check for Javascript",
  "url": "/webappsec/tools/javascript-tools/javascript-dependency-checker.html",
  "tags": "",
  "content": "NSP  Node Security Project (nsp) checks the dependencies in your project’s package.json against libraries of known vulnerabilities. If your project uses vulnerable versions of a dependency, it will let you know and provide helpful details.  Installation  $ npm install --save-dev nsp  Usage  Running $ nsp check inside your project will generate a well formatted report in stdout  You can of course us the -o/--output option to write the results to a file.  CI Integration  Some basic best practices and guidelines for adding nsp to your CI pipeline can be found here: https://github.com/cairnsc/security-playbook/blob/master/tooling/dependency-checker/npm-dependency-checkers.md  check-dependencies  At the moment, we’d really recommend nsp – it’s a great tool! But if that doesn’t work for your project, here are some alternatives.  npm install --save-dev check-dependencies   and then use exactly as you’d think :)"
},{
  "title": "Secrets management for Javascript",
  "url": "/webappsec/tools/javascript-tools/javascript-secrets-management.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Static analysis for Javascript",
  "url": "/webappsec/tools/javascript-tools/javascript-static-analysis.html",
  "tags": "",
  "content": "eslint  Installation  $ npm install --save-dev eslint eslint-plugin-security eslint-plugin-scanjs-rules eslint-plugin-no-unsafe-innerhtml   Configuration  Here is a sample .eslintrc.json file, for use with those plugins:  {     //adjust these as necessary for your application     \"env\": {         \"es6\": true,         \"node\": true     },     //uncomment this line if you are getting errors like \"Parsing error: Unexpected token\"     //\"parser\": \"babel-eslint\",     \"parserOptions\": {         \"ecmaFeatures\": {             \"jsx\": true         },         \"sourceType\": \"module\"     },     \"plugins\": [         //\"react\",         \"no-unsafe-innerhtml\",         \"security\"     ],     \"rules\": {     /** useful rules from eslint, if you want them **/      /** security plugin rules **/     \"no-unsafe-innerhtml/no-unsafe-innerhtml\" : 2,     \"security/detect-non-literal-fs-filename\": 2,     \"security/detect-non-literal-regexp\": 2,     \"security/detect-unsafe-regex\": 2,     \"security/detect-buffer-noassert\": 2,     \"security/detect-child-process\": 2,     \"security/detect-disable-mustache-escape\": 2,     \"security/detect-eval-with-expression\": 2,     \"security/detect-no-csrf-before-method-override\": 2,     \"security/detect-non-literal-require\": 2,     \"security/detect-object-injection\": 2,     \"security/detect-possible-timing-attacks\": 1,     \"security/detect-pseudoRandomBytes\": 2   } }   Alternately, you can run $ eslint --init with your project-specific details and include the plugins and rules from our config file.  If you are using the eslint specific to your project, you might have to run $ ./node_modules/eslint/bin/eslint.js --init. This will result in many non-security related linting rules which you can disable by commenting out \"extends\": \"blah\", in the .eslintrc file generated by your init.  You might want to create a file called .eslintignore (or something) containing the line node_modules/. You can then specify the option --ignore-path .eslintignore when you run eslint. This will save you a lot of false positives.  Usage  For a quick start, try:  $ cd my_project $ eslint .   To create an HTML output file you can view in your browser, try:  $ eslint --ignore-path .eslintignore -f html -o eslint-report.html ."
},{
  "title": "Logging",
  "url": "/webappsec/best-practices/logging.html",
  "tags": "",
  "content": "Enable Logging Logs can help you detect and respond to potential malicious behavior in your application.  OWASP Logging Cheat Sheet AWS CloudTrail"
},{
  "title": "NodeJS Checklist",
  "url": "/webappsec/checklists/javascript-checklists/nodejs.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Orphaned Systems",
  "url": "/netsec/best-practices/orphaned-systems.html",
  "tags": "",
  "content": "Try to identify systems that are no longer being cared for and no longer needed. Create a plan for retiring these systems."
},{
  "title": "Other Tricks",
  "url": "/webappsec/fundamentals/other-tricks.html",
  "tags": "",
  "content": "Referrers  There are several things you can do to try to prevent the browser from sending referers          Add the attribute rel=”noreferrer” to links. This only protects links, and is not universally supported by browsers.           Replace links with Data URIs that reload to the new URL, hiding the referer. This only protects links. For example:      &lt;a href=\"data:text/html,&lt;meta http-equiv='refresh' content='0; url=https://example.org'&gt;\"&gt;example.org&lt;/a&gt;      Add a Content Security Policy (v1.1 or later) with a restrictive referer directive. This does not work in all browsers.   These are all good ideas for increasing the user’s privacy, but should not be relied on to mitigate the problems associated with sensitive information in the URL.  Same Origin     Abusing same origin policy            how it works       how it falls down                    CSRF                            different origin writes allowed               tags for: forms, images, assets are allowed                                   dns rebinding                       best pratices           javascript can only phone home   CORS can allow scripts to violate the same origin policy   every javascript that is loaded can read (most) everything on the page and send the information back to its origin.   javascript cannot read ‘tainted’ assets that have been loaded dynamically from different domains."
},{
  "title": "Patch Management",
  "url": "/netsec/best-practices/patch-management.html",
  "tags": "",
  "content": "A deliberate patch management plan is required for all service owners and sysadmins.  Although every development team, service owner or system administrator will determine their own particular plan, what is vitally important is that there is a plan in place.  System Patching Standards     Critical/High security updates should be applied as soon as possible but no later than 48 hours after they have been published.   Medium/Low security updates can wait until a standard maintenance window or weekly/monthly scheduled patching.   If possible, package updates should be installed and tested in a test/dev/staging/uat environment before being deployed in production.  Automatic Updates  Windows  Turn on automatic updates.  Mac  Turn on automatic updates.  Linux  RedHat/Centos/Amazon Linux  Method 1  https://www.centos.org/docs/5/html/yum/sn-updating-your-system.html  The yum package supplied with CentOS includes scripts to perform full system updates every day. To activate automatic daily updates, enter this command:  sudo '/sbin/chkconfig --level 345 yum on &amp;&amp; /sbin/service yum start'   Method 2: use “yum-cron” tool  Enabling automatic updates in Centos 6 and Red Hat 6 (yum-cron version 3.2.29 for CentOS 6):  https://linuxaria.com/pills/enabling-automatic-updates-in-centos-6-and-red-hat-6  Automatic updates for CentOS: yum-cron installing and configuring (yum-cron version 3.4.3, for Amazon Linux and CentOS 7): https://jonathansblog.co.uk/yum-cron  Debian/Ubuntu  Install the packages unattended-upgrades and apt-listchanges:  apt-get install unattended-upgrades apt-listchanges      unattended-upgrades will automatically install updates.   apt-listchanges will send you email alerts when there are new versions available (defaults to root).   To test to make sure it will work:  unattended-upgrade -d   For more information, see https://wiki.debian.org/UnattendedUpgrades  Manual Updates  Redhat/Centos  Make sure you have the yum security plugin installed:  # yum -y install yum-plugin-security   Update yum’s metadata:  # yum updateinfo   Check to see what security updates need to be installed:  # yum updateinfo list sec   Install the security updates:  # yum -y update-minimal —security   If you want to install all the available updates, do this:  # yum -y update   Debian/Ubuntu  Manual update:  # apt-get update &amp;&amp; sudo apt-get -y upgrade   Ansible  Syntax to run the playbook manually:  ansible-playbook -i inventory update-machines.yml -u &lt;username&gt; -kK   The inventory file is just a list of machines:  elkkeyrecdb01.thoughtworks.com elkkeyrecdb02.thoughtworks.com elkkeyrecprod01.thoughtworks.com elkkeyrecprod02.thoughtworks.com elkkeyrecstaging01.thoughtworks.com elkkeyrecstaging02.thoughtworks.com   update-machines.yml is the ansible playbook. Here is some sample syntax:  --- - hosts: all   sudo: yes    tasks:     - name: Install security plugin       yum: pkg=yum-plugin-security state=present      - name: Update yum metadata       command: yum updateinfo      - name: See what updates are going to be installed       command: yum check-update --security       register: packageList      - debug: msg=\"The following packages will be updated \"      - name: Install security updates       command: yum -y update --security   Here’s another playbook example:  --- - hosts: all   sudo: yes    tasks:       - name: update all packages         action: yum name=* state=latest"
},{
  "title": "Dependency check for Python",
  "url": "/webappsec/tools/python-tools/python-dependency-checker.html",
  "tags": "",
  "content": "Safety  Safety a very strong choice for your Python project. It’s easy to install, easy to use, and accumulates information from several sources to give you as much, or as little information as you need. Not to mention the README comes with a set of instructions for CI Pipeline integration :)  Installation  $ pip install safety   Usage  I find I get the best results when I explicitly tell Safety to look at my requirements file.  safety check -r requirements.txt   This will output the name, installed version, and affected version of the vulnerable dependency.  If you’re looking for more information, you can run a full report:  $ safety check -r requirements.txt --full-report   This outputs the corresponding CVE, descriptions of the issue as collected from multiple sources, and even relevant links to follow for more details.  If you are combining Safety with other vulnerability scanning tools, or if you are using it in your CI pipeline, it might make the most sense to output only the names of the vulnerable packages.  $ safety check -r requirements --bare   Documentation  Check out the GitHub project: https://github.com/pyupio/safety  OWASP Dependency Check  This dependency checker from OWASP is widely used and actively developed. It is compatible with Java/.NET, and there is currently experimental support other languages including Python. Given the experimental nature of the project at this time (July 21, 2017), Safety is likely a better option for your Python project.  Installation  There are a few ways to install dependency-check, but our best experience has been installing with Homebrew:  $ brew update &amp;&amp; brew install dependency-check   You can also download the dependency-check-cli zip file.  Usage  Dependency-check requires two arguments:     --scan (path to project you would like to scan)   --project (choose the name you would like for your project)   Check out the --advancedHelp option for some very specific options that could be well-suited to your project.  With Python projects, it is advisable to use the --enableExperimental flag since the features that scan Python files are still considered experimental by the Dependency Check project (don’t worry, we’re pretty confident in it regardless).  By default, the HTML report will be saved to whatever directory you are in when you run the scan. This file will be overwritten if no -o/--output or -f/--format are specified. Keep this in mind if you integrate this into your pipeline (as we hope you do!).  Documentation  The full documentation and the latest downloads can be found at: https://jeremylong.github.io/DependencyCheck/index.html"
},{
  "title": "Secrets management for Python",
  "url": "/webappsec/tools/python-tools/python-secrets-management.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Static analysis for Python",
  "url": "/webappsec/tools/python-tools/python-static-analysis.html",
  "tags": "",
  "content": "Bandit  Bandit is a static security analysis tool for Python. Bandit is meant to find the common issues, so please don’t take a passing scan to mean bullet-proof code. You may want to use Bandit in conjunction with a language-agnositc analysis tool like Grepbugs.  Its README.rst is pretty great (somehow both extensive and succinct), so I won’t say too much here.  Installation  pip install bandit f```  ### Usage   bandit -r /path/to/code ```  Some Note  When you have run a scan with bandit, be sure to pay special attention to the following lines in the output:  Code scanned:   Total lines of code: 645   Total lines skipped (#nosec): 0   Make sure those numbers make sense – if you forget to set the -r option, bandit will not scan your project directories recursively.  Similarly, try running bandit with the --verbose option the first time you run it (or whenever you are trying to debug). It lists files included in and excluded from the scan."
},{
  "title": "Rails 4 Pre-flight Checklist",
  "url": "/webappsec/checklists/ruby-checklists/rails-4.html",
  "tags": "",
  "content": "Configuration  The config.force_ssl flag is enabled  In environments/production.rb:  config.force_ssl = true   What this does     This will set a HSTS header in application responses, set the secure flag for cookies, and redirect HTTP to HTTPS.   Why this is important     Even if the web server is configured to require TLS, you probably have a redirect configured from plain HTTP to HTTPS. In these cases, there are many situations where a browser might make a plain HTTP connection attempt, potentionally leaking session information in the clear. By adding an HSTS header and setting the secure flag for cookies, you instruct the browser to always require HTTPS.   Database credentials are stored in the environment  To be written  Anti-CSRF is enabled  Make sure that the top of ApplicationController has protect_from_forgery:  class ApplicationController &lt; ActionController::Base   protect_from_forgery with: :exception end   This is the default when you create a new rails 4 application, but if you upgraded you might not have this.  What this does     Enabling protect_from_forgery will set a value session[:_csrf_token] and include authenticity_token as a parameter to all your POST requests. If the values don’t match, the exception ActionController::InvalidAuthenticityToken is raised.   Why this is important     When a web browser submits a HTTP request, it dutifully includes all matching cookies, regardless of what web page the request came from. Without CSRF protection, a nefarious page can get your browser to make requests to a protected site while authenticated as you.   Important details     Don’t disable exceptions: Be very careful if changing with: :exception: there are many ways to introduce a vulnerability if you do anything other than throw an exception when the authentity_token does not validate. https://nvisium.com/blog/2014/09/10/understanding-protectfromforgery/   Idempotent HTTP GET: You must remember to make all GET actions idempotent (does not change the data). This is because the Rails anti-CSRF only applies to HTTP POST.   Images are not protected: Images and other assets are not protected by the Rails anti-CSRF or the same-origin policy. If you have images with sensitive information, then you need an additional system to prevent a third party site from stealing these images.   If the application has a XSS vulnerability, then CSRF is also defeated.   See also     http://guides.rubyonrails.org/v4.2/security.html#csrf-countermeasures   https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)   Cookies and sessions  Authentication always triggers a session reset  You must always call reset_session immediately before setting the user id in the session. For example:  class SessionController &lt;&lt; ApplicationController   def create     user = User.authenticate(params[:username], params[:password])     if user       reset_session       session[:user_id] = user.id       redirect_to users_path(user)     else       ...     end   end end   What this does     By resetting the session before setting critical information in the session, you protect against session fixation attacks.   Why this is important     There are many ways that an attacker can “pre-seed” a session cookie in the target’s browser. Once this is done, browsers follow a simple rule with cookies: if they have a cookie that matches the site, they send the cookie. Because of this, the website has no way to distinguish between legitimate session cookies that are created by the target and nefarious session cookies created by the attacker (and injected into the target’s browser).   Important details     Encrypted and signed session cookies offer no defense against session fixation.   Even if you are using a third party authentication framework, you may still need to worry about calling reset_session yourself. This is true when the framework does not manage the session for you, but just handles the authentication (for example, omniauth).   See also     http://guides.rubyonrails.org/v4.2/security.html#session-fixation   If used, CookieStore is used carefully  By default, Rails applications will use ActionDispatch::Session::CookieStore for sessions. CookieStore is fast, but there are several pitfalls to be aware of when using CookieStore.  Do not store anything in the session…:     That is large: Cookies have a strict limit of 4k.   That you don’t want the user to see: Cookies are not encrypted, they are merely authenticated with a SHA1 digest.   That can be replayed: The user can always restore an older version of the cookie, so you can’t trust any state information stored in the user’s session.   Don’t change the default config/secrets.yml:      production:       secret_key_base: &lt;%= ENV[\"SECRET_KEY_BASE\"] %&gt;   This requires a valid session secret be created in the environment. Don’t modify this to fall back to a default value if the environment variable is not set.  Because CookieStore is easy to mess up or mis-configure, many people prefer using a traditional database-backed session storage instead.  Assets  All stylesheets have absolute paths  All stylesheets have absolute paths (to prevent CSS-injection via “Relative Path Overwrite”)  What this does     To be written   Why this is important     To be written   HTTP Headers  The gem secureheaders is enabled  The gem secureheaders allows you to conveniently configure many of best practices for HTTP headers and cookie flags.  In the apps Gemfile:  gem 'secureheaders'   In config/initializers/secure_headers.rb:  SecureHeaders::Configuration.default   What this does     Enabling this gem will give you the following default headers:   Content-Security-Policy: default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline' Strict-Transport-Security: max-age=631138519 X-Content-Type-Options: nosniff X-Download-Options: noopen X-Frame-Options: sameorigin X-Permitted-Cross-Domain-Policies: none X-Xss-Protection: 1; mode=block      And cookies:    Set-Cookie: ....; Secure; HttpOnly; SameSite=Lax      Why this is important     By default, web browsers are very lax and forgiving, which is what creates a wide variety of opportunities for attack. The default headers set by secureheaders are best practices that instruct the browser to behave more strictly, and to permit many fewer avenues of attack. These options might not work with your application out of the box, but you should modify your application, if possible, to allow your site to work with these headers enabled.   Important details     secureheaders does nothing to prevent sensitive information from being cached by the web browser. For this, you must set Cache-Control header to no-store. See below.   See also     For more configuration options, see https://github.com/twitter/secureheaders/   https://www.owasp.org/index.php/Content_Security_Policy_Cheat_Sheet   TODO     Decide on CSP recommendation, given the vulnerabilities in almost all CSPs that don’t use a separate domain for assets.   Explore a more strict recommendation than the secureheaders default.   Sensitive content is not cached  If your application has sensitive content, you should instruct the browser to not cache the pages at all:  class ApplicationController &lt; ActionController::Base   before_filter :no_cache_header   protected   def no_cache_header     response.headers[\"Cache-Control\"] = \"max-age=0, private, no-store\"   end end   The important element here is no-store. The Rails default of no-cache does not prevent the browser from caching the result. It just prevents the browser from using it’s cached copy without first requesting the headers to see if the content has changed.  What is the attack here? Without no-store set, anyone who walks up to the browser and opens the cache will get the full content of all pages that a user has recently visited. Only the no-store option for Cache-Control will prevent the page contents from being saved and accessible via the browser’s cache.  To view the cache, open these in the browser’s location bar:     Chrome: chrome://cache   Firefox: about:cache   Also, you should make sure that cookies and localstorage are cleared when the user logs out.  Why this is important     Web browsers store on disk and in memory a lot of information about your site, information that is potentially very sensitive. If there is a concern that an attacker might gain physical access to a computer, then it is best to make sure your site does not have it’s pages and localstorage saved.   Databases  All queries use parameter binding  For example, this:  User.where(:name =&gt; params[:name])   But NOT this:  User.where(\"name = '#{params[:name]}'\")   Some ActiveRecord methods do not use parameter binding, even though it looks like they should. For example, these are vulnerable to SQL injection:  User.calculate(:sum, params[:column]) User.exist?(params[:id])   The exist? method in ActiveRecord only performs sanitization on string arguments. But an attacker can easy craft a request that results in params[:id] being an array. For example:  User.exist?([\"id = 1) AND 0; --\"])   Will result in the following SQL:  SELECT 1 AS one FROM \"users\" WHERE (id = 1) AND 0; --) LIMIT 1   Why it is important     Parameters queries, or stored procedures with binding, are the only way to prevent SQL injection. Please do not attempt to write your own sanitization routines: it is very difficult to account for all the weird ways in which nefarious strings can get passed your filters.   TODO     There does not appear to be a proper way to do parameter binding when making SQL calls using the database connection object directly (e.g. User.connection.select_values). Recommendation? Use sequel gem?   Views  All output is filtered  Remember, all user input should be treated as untrusted and potentially hostile. This is true even if you have attempted to filter this input and only store “safe” values in the database.  By default, Rails will filter all strings that are rendered to the page:  &lt;%= possibly_user_input %&gt;   However, Rails also lets you easily bypass the filtering. All these will create the possibility of a XSS vulnerability:  &lt;%= raw possibly_user_input %&gt; &lt;%= possibly_user_input.html_safe %&gt; &lt;%= content_tag possibly_user_input %&gt; &lt;%= link_to \"Website\", possibly_user_input %&gt;   The methods raw and html_safe should used with extreme caution, and only on strings that have no user supplied input.  Routing and URLs  There is no sensitive information in any application URLs  For example, the application should never have ?session_id=e1e6a6acadc40d2 in the URL, even for requests which redirect and do not load any page content.  Why this is important     Browsers send the HTTP referrer to whatever links a user clicks on, potentially leaking the sensitive URL. Even if that is not a possibility, the browser will still send the referrer for other requests triggered by the page, such as images an stylesheets.    There are several attacks that can take advantage of this fact to exfiltrate any sensitive information in the URL. For example, “Relative Path Overwrite”.    You can still include sensitive information in the request parameters, but these values must not appear in the URL part of the request.   Authorization  The default is to require authorization  There are two approaches to authorization:     The good way: require authorization by default, and then explicitly skip it when not needed.   The bad way: have no default authorization, and only require it when needed.   The good way:  class ApplicationController &lt; ActionController::Base   before_action :require_authorization    protected    def require_authorization     ...   end end  class HomeController &lt; ApplicationController   skip_before_action :require_authorization, only: :index   ... end   The bad way:  class ApplicationController &lt; ActionController::Base   protected   def require_authorization     ...   end end  class InventoryController &lt; ApplicationController   before_action :require_authorization   ... end   Why this is important     For something critical like authorization, you want to practice defensive programming. If there is an error in how authorization is defined for an action, it is much better to fall back to a safe default, or a hard fail, rather than to fall back to a state that leaves your application open to attack.   Pipeline  See [[ruby-tools]] for running dependency check and static analysis in your CI pipeline.  Links     http://guides.rubyonrails.org/v4.2/security.html   https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet   https://thoughtworks.jiveon.com/docs/DOC-43719   https://rorsecurity.info/   HTML5 Security Cheatsheet https://html5sec.org/"
},{
  "title": "Rails 5 Checklist",
  "url": "/webappsec/checklists/ruby-checklists/rails-5.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Remote Logging",
  "url": "/netsec/best-practices/remote-logging.html",
  "tags": "",
  "content": "Make sure that the team’s systems are logging to Sumo Logic.  step one: identify the key strategic systems that should be logging remotely. step two: work with infosec to get these logging to sumo logic."
},{
  "title": "Dependency check for Ruby",
  "url": "/webappsec/tools/ruby-tools/ruby-dependency-checker.html",
  "tags": "",
  "content": "bundler-audit  The bundler-audit command will examine your Gemfile.lock to check for vulnerable versions of gems.  Installation  $ gem install bundler-audit   Usage  $ bundle-audit update $ bundle-audit check   For use in a pipeline, you can combine update and check together like so: $ bundle-audit check --verbose --update. The --verbose option will print out additional information about the identified vulnerability.  Run in your pipeline  Ideally, dependency checkers should be integrated into your CI pipeline. Think of this as a test (a security test) that will run as your others do and fail if either:     You have vulnerable dependencies   Updating your vulnerable dependencies causes another issue   This will, of course, depend on your configuration and what works best for your team.  For example, in .gitlab-ci.yml:  stages:   - build   - checks   - test   - deploy  bundle_audit:   stage: checks   script: |     gem install bundler-audit     bundle-audit check --update ...   Run in pre-commit  If your team uses a pre-commit script, you could run a bundler-audit check as part of that script.  Keep in mind that, if you will be using the update option, it’s probably a good idea to:     run your tests   run bundle-audit --update   run your tests again so that you can definitively tell if the update is what broke your tests."
},{
  "title": "SAML with Ruby",
  "url": "/webappsec/tutorials/ruby-saml.html",
  "tags": "",
  "content": "Terminology     Identity Provider (IdP): The SAML identity provider. In our case, this will be Okta.   Service Provider (SP): The application you are creating.   Metadata URL: A URL that specifies the location of a metadata.xml file that defines how your application is configured for use with a particular IdP. Typically, your application will check this URL each time it is started and download the contents of the file.   Create an app in Okta  Create a developer account  Add an application  The SSO endpoint for this application is:     development: http://localhost:3000/saml/acs   production: https://DOMAIN/saml/acs   In Okta, this URL would be specified for both Single Sign on URL and Audience URI.  Once the identity provider is configured, copy the IdP metadata URL.  Basic service provider  Set environment variable  Then, set the environment variable IPD_METADATA_URL before the application is run. For example:  In config/development.sh:  export IDP_METADATA_URL=\"https://dev-770989.oktapreview.com/app/exk9dbq3zdHbEBp2e0h7/sso/saml/metadata\"   Then, to run your application:  source config/development.sh rails server   In production, you would set the environment viariable via a deployment pipeline.  Gemfile  In Gemfile  gem 'ruby-saml', '~&gt; 1.4'   Routes  in config/routes.rb:  Rails.application.routes.draw do   get 'saml/login', to: 'saml#login', as: 'login'   post 'saml/acs',  to: 'saml#acs' end   SAML Controller  in app/controllers/saml_controller.rb:  # # A SAML service provider controller #  class SamlController &lt; ApplicationController   skip_before_action :verify_authenticity_token, :only =&gt; [:acs]   skip_before_action :require_authentication   skip_before_action :require_authorization    #   # GET /saml/login   #   # SP initiated login action. Redirects to IdP.   #   def login     request = OneLogin::RubySaml::Authrequest.new     redirect_to(request.create(saml_settings))   end    #   # POST /saml/acs   #   # Assertion Consumer Service URL. The endpoint that the IdP posts to.   #   def acs     response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :settings =&gt; saml_settings)     reset_session     session[:user_id] = response.nameid     redirect_to start_url   end    #   # POST /saml/logout   #   def logout     reset_session     redirect_to root_url   end    private    def saml_settings     @settings ||= begin       if ENV['IDP_METADATA_URL'] &amp;&amp; ENV['IDP_METADATA_URL'].present?         OneLogin::RubySaml::IdpMetadataParser.new.parse_remote(ENV['IDP_METADATA_URL'])       else         raise StandardError, \"The environment variable IDP_METADATA_URL is not set.\"       end     end   end  end   This controller assumes you have routes for start_url and root_url. This also assumes you have a require_authentication and require_authorization before action callbacks defined. Change these as appropriate.  Login link  Put this in a view somewhere:  &lt;%= link_to \"Log in\", login_path, class: 'login-btn' %&gt;   Add support for groups  Lets suppose you want to give access to your application to these three groups that are defined in Okta:     app_developers, with Okta group ID 0000aaaa   app_admins with Okta group ID 1111bbbb   app_readers with Okta group ID 2222cccc   The actual group IDs in Okta look more like 00g1erqthk0Why5qd0h8, but for the purpose of this tutorial we have simplified the IDs.  Add groups attribute to Okta  The first step is to modify the application configuration in Okta to add a SAML property:     Name: groups   Value: getFilteredGroups({\"0000aaaa\",\"1111bbbb\", \"2222cccc\"}, \"{group.id,group.name}\", 10)   Configure environment  Lets suppose you want to add two simple roles to your application:     Administration role: These users can edit everything.   Read only role: These users can read but not edit.   For this, create the following environment variables:  ADMIN_GROUPS – A list of SAML group IDs for users who should have full admin access to the web application.  READONLY_GROUPS – A list of SAML group IDs for users who should have READ ONLY access to the web application.  For example, in config/development.sh:  export ADMIN_GROUPS=\"0000aaaa 1111bbbb\" export READONLY_GROUPS=\"2222cccc\"   In this examples, app_developers and app_admins both gain the admin role, and app_readers gain the readonly role.  Modify SAML controller  First, add a call to resolve_group_role. This will store the role and the group name in the session when the user authenticates.    #   # A SAML service provider controller   #    class SamlController &lt; ApplicationController      def acs       response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :settings =&gt; saml_settings)       reset_session       session[:user_id] = response.nameid +     session[:role], session[:group] = resolve_group_role(response)       redirect_to start_url     end   Now lets define resolve_group_role:    class SamlError &lt; StandardError; end   rescue_from SamlError, :with =&gt; :error    private    def error(exception)     render status: 500, text: exception.to_s   end    def resolve_group_role(response)     group_str = response.attributes[\"groups\"]     if group_str.nil?       raise SamlError, \"The SAML response must include the `groups` attribute. See README.md\"     end     groups = parse_user_groups(group_str)     if group = find_group(groups, ENV['ADMIN_GROUPS'])       return [:admin, group]     elsif group = find_group(groups, ENV['READONLY_GROUPS'])       return [:reader, group]     else       raise SamlError, \"You do not belong to any groups with access to this application. Your groups are #{groups.inspect}.\"     end   end    #   # parses the list of groups that a user is a member of, as reported by saml assertion.   #   # configured in okta:   #   #   groups =&gt; getFilteredGroups({\"00gcyt4a07m0hu0pe0h7\",\"00gcyt4j78O335Ntv0h7\"}, \"{group.id, group.name}\", 10)   #   # example response.attributes[\"groups\"]:   #   #   \"00gcyt4a07m0hu0pe0h7,inventory_read,00gcyt4j78O335Ntv0h7,inventory_write\"   #   # NOTE: this will fail horribly if there is a comma in the group name.   #   def parse_user_groups(group_str)     groups = {}     ids_and_names = group_str.split(',')     while ids_and_names.any?       id = ids_and_names.shift.strip       name = ids_and_names.shift.strip       groups[id] = name     end     return groups   rescue     raise SamlError, \"ERROR: failed to parse `group` attrbute string from SAML. The string was: #{group_str.inspect}\"   end    #   # returns a group, in the form {id: group.id, name: group.name}, of the first group   # we can find that is in both user_groups and target_groups   #   # user_groups: a hash of group names, indexed by group id   # target_groups: a string of group ids, separated by commas or whitespace   #   def find_group(user_groups, target_groups)     if target_groups       target_groups.split(/[\\s,]+/).each do |group_id|         if user_groups[group_id]           return {id: group_id, name: user_groups[group_id]}         end       end     end     return nil   end  end   How would you use this? Here is a very barebones authorization code you might use:  class ApplicationController &lt; ActionController::Base   NotAuthorized = Class.new(StandardError)    before_action :require_authentication   before_action :require_authorization    rescue_from ApplicationController::NotAuthorized, :with =&gt; :render_unauthorized    protected    def render_unauthorized     render :file =&gt; Rails.root.join('public', '422.html'), :status =&gt; 403   end    def current_user     if Rails.env != \"production\" &amp;&amp; ENV[\"AUTHENTICATION_BYPASS\"]       session[:role] = \"admin\"       ENV[\"AUTHENTICATION_BYPASS\"]     else       session[:user_id]     end   end   helper_method :current_user    def require_authentication     unless current_user       redirect_to login_url     end   end    def require_authorization     if is_admin?       return true     elsif is_reader? &amp;&amp; read_only_request?       return true     else       raise NotAuthorized     end   end    def is_admin?     session[:role] == \"admin\"   end   helper_method :is_admin?    def is_reader?     session[:role] == \"reader\"   end   helper_method :is_reader? end"
},{
  "title": "Secrets management for Ruby",
  "url": "/webappsec/tools/ruby-tools/ruby-secrets-management.html",
  "tags": "",
  "content": "To be written"
},{
  "title": "Static analysis for Ruby",
  "url": "/webappsec/tools/ruby-tools/ruby-static-analysis.html",
  "tags": "",
  "content": "Brakeman  Brakeman is a great and free static analysis tool for Rails. It does not catch all vulnerabilities, but it contains a wealth of knowledge regarding best practices.  One great aspect of brakeman is that, not only does it scan your code and alert you to potential security bugs, but it also provides extensive documentation to help you understand the dangers of each vulnerability.  Installation  $ gem install brakeman   Usage  $ brakeman my-project/   You can specify the Rails version with -4 or -5.  My personal favorite way to run Brakeman if I’ve got time:  $ brakeman my-project/ -A -f html -o brakeman-report-DATE.html   My personal favorite way to run Brakeman if I’ve already run a few scans:  $ brakeman my-project/ --faster -confidence-level 2 -f html -o brakeman-report-DATE.html   Checkout further documentation on Brakeman options here.  Run in your pipeline  For example, in .gitlab-ci.yml:  stages:   - build   - checks   - test   - deploy  brakeman:   stage: checks   script: |     gem install brakeman     brakeman ...   Dawnscanner  Dawnscanner is a source code security analysis tool that is compatible with Rails, Sinatra, and Padrino.  Installation  $ gem install dawnscanner  Alternately, you can verify the gem’s signature. To be sure the gem you install hasn’t been tampered with, first add paolo@dawnscanner.org public signing certificate as trusted to your gem specific keyring.  $ gem cert --add &lt;(curl -Ls https://raw.githubusercontent.com/thesp0nge/dawnscanner/master/certs/paolo_at_dawnscanner_dot_org.pem) $ gem install dawnscanner -P MediumSecurity   Rubocop  Rubocop is source code analysis tool, primarily designed to “lint” your code. It is not specifically meant for finding security bugs, but can be configured to be useful for this purpose.  One benefit of Rubocop is that it can act as your linter as well as provide some light security analysis. If you are using a framework like Rails or Sinatra, Brakeman or Dawnscanner (respectively) are probably better bets for security-specific analysis.  That being said, Rubocop is highly configurable, and has extensive documentation. You can pick and choose which rules (aka cops) to use, and you can even write your own.  Installation  $ gem install rubocop   For more details, see the rubucop documentation).  Usage  Analyzing your files with Rubocop is as simple as running  $ cd my_project $ rubocop   Of course, there are some fancier options as well. Some particularly interesting ones for security purposes are:  --except  Allows you to exclude particular cops or departments (the general category that cops reside in, i.e. Department = Layout, cops = SpaceBeforeComma, TrailingWhitespace, etc.)  --only  The opposite of the except option  -D/--display-cop-names  This will include the cop names in the output so you can see which cops are particularly useful and/or noisy. This might help you figure out which to use with --except and --only.  Of course, you can find all of the other available options in the usual ways.  Configuration  You can customize the config file, and even specify mulitple config files at runtime.  You can also specify inherit_from in your .rubocop.yml config file. You can inherit from other files in your project, as well as a remote URL."
},{
  "title": "Secrets Management",
  "url": "/webappsec/best-practices/secrets-management.html",
  "tags": "",
  "content": "### What is it?  Secrets such as passwords, credentials, access tokens, certificates, and other confidential information are something we can't allow to fall into the wrong hands. A secret management tool makes it possible to manage these kinds of secrets safely.  ### Why is it needed?  We see this more than you'd think. The dangers of leaving secrets into your code are wide ranging and severe. It could lead to everything from an attacker compromising a user's session to full owning your application, and even the application server, gaining access to your database, and impersonating you to uncover more valuable data (and this is not an exhaustive list).  * Applications rely on secrets to access services such as databases, encrypted files, and to securely communicate with other applications and systems. * Team members may also need a way to manage and share similar confidential information. * Writing secrets in a place they can be easily retrieved exposes projects to unnecessary risks. This includes doing things like writing them on sticky notes or in source code or configuration files.  ### Tools  * [[agnostic-secrets-management]]"
},{
  "title": "Security Advisories",
  "url": "/netsec/best-practices/security-advisories.html",
  "tags": "",
  "content": "### Step 1 - Create a Patch Management List  First, create a list of all the major software that your systems rely on but that are not checked automatically using a dependency checker in a test pipeline. For example, you do not need to add libraries that a web application depends on to your patch management list, but you should add the operating system, the web server, the database server, and so on.  ### Step 2 - Identify notification sources  For every item in your list, write down the URL for where you can find canonical vulnerability information. All major software projects will offer this. Often, you can also subscribe to a mailing list.  Alternately, there are commercial services that will handle this patch management notification for you.  ### Step 3 - Set the date  Pick a day on the calender where you will check every URL on your list to see if there are any new vulnerabilities listed since the last time you checked."
},{
  "title": "Static analysis",
  "url": "/webappsec/best-practices/static-analysis.html",
  "tags": "",
  "content": "### What is it?  A static analysis tool, referred to as a Static Application Security Tool (SAST) in the context of security, identifies potential security flaws in source code, byte code, and binaries. SAST tools provide a powerful way to identify potential defects by analyzing applications from the \"inside out\". This provides much greater sight into possible flaws than a scanner that only interacts with a application as a user would.  ### Why is it needed?  * Sometimes the easiest or most obvious way to do something is also not secure.   These tools provide fast feedback if a mistake is made. * Continuous, fast feedback about potential vulnerabilities saves teams time and   stress.  ### When should I use this?  * In your CI pipeline. Automatically run the scanner periodically, possibly   alongside other automated tests following a checkin if it can complete quickly   enough. * During manual testing. More in-depth scans can be run and verified along with   the other necessary manual tests. Testers can also start to do some   exploratory security testing after familiarizing themselves with typical   weaknesses.  ### Tools  * [[agnostic-static-analysis]] * [[java-static-analysis]] * [[javascript-static-analysis]] * [[python-static-analysis]] * [[ruby-static-analysis]]  ### Further reading  * [Wikipedia page on static program analysis](https://en.wikipedia.org/wiki/Static_program_analysis) * [Wikipedia list of static program analyzers](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis) * [OWASP wiki page on static program analysis](https://www.owasp.org/index.php/Static_Code_Analysis) * [NIST list of security-focused static program analyzers](https://samate.nist.gov/index.php/Source_Code_Security_Analyzers.html)"
},{
  "title": "System Administrators",
  "url": "/netsec/best-practices/system-administrators.html",
  "tags": "",
  "content": "Create a list of responsible sysadmins. These are the folks we need to engage with directly. (sysadmin here would mean anyone with access to an VPC control panel or with SSH access to the server).  Review offboarding procedures for sysadmins with privileged access."
},{
  "title": "Systems Inventory",
  "url": "/netsec/best-practices/systems-inventory.html",
  "tags": "",
  "content": "Create a list of systems, physical and virtual, owned by the team. IP Address, Hostname, OS, and Role. Ensure that this system inventory is scanned by Tenable Security Center, or otherwise input into the inventory tracker, and that the team is assigned ownership of these assets."
},{
  "title": "Threat Modeling",
  "url": "/netsec/threat-modeling.html",
  "tags": "",
  "content": "https://www.owasp.org/index.php/Threat_Risk_Modeling  https://www.schneier.com/academic/archives/1999/12/attack_trees.html  https://msdn.microsoft.com/en-us/library/ff648644.aspx    Step 1. Identify Assets   Step 2. Create an Architecture Overview   Step 3. Decompose the Application   Step 4. Identify the Threats   Step 5. Document the Threats   Step 6. Rate the Threats  ## Work and data flows  * identify what assets the team owns * identify what data is in them * map the flow of data * classify the data * mitigate the highest risk first"
},{
  "title": "Network Security Tools",
  "url": "/netsec/tools.html",
  "tags": "",
  "content": "## CyberChef  Swiss Army Knife for encoded information: does conversions, decryption, hashing, everything. Very handy!  https://gchq.github.io/CyberChef  ## Snoopy Logger  https://github.com/a2o/snoopy logs all shell commands to syslog not useful for forensics, because it can be bypassed, but useful to audit what has happened manually and if an attacker doesn't know its there.  ## VULNREPORT  http://vulnreport.io/  automation and management platform for penetration tests and security audits"
},{
  "title": "Vulnerability Scanning",
  "url": "/netsec/best-practices/vulnerability-scanning.html",
  "tags": "",
  "content": "Make sure that the team's systems are being scanned. Review the scan results and remediate all vulnerabilities.  Ensure that all the assets are being scanned, set up VPC peering connections as needed. Check the latest scan, and ensure that there are no items that need to be addressed"
},{}
]
